# Merch Shop (Avito Trainee Task)

[![Go Report Card](https://goreportcard.com/badge/github.com/0x0FACED/merch-shop)](https://goreportcard.com/report/github.com/0x0FACED/merch-shop)


Это мое решение тестового задания в Avito на позицию Backend Developer.

## Table of Contents

- [Merch Shop (Avito Trainee Task)](#merch-shop-avito-trainee-task)
  - [Table of Contents](#table-of-contents)
  - [Подход к решению задачи](#подход-к-решению-задачи)
  - [Архитектура сервера](#архитектура-сервера)
  - [Обработка ошибок](#обработка-ошибок)
  - [Проектирование базы данных](#проектирование-базы-данных)
  - [TODO](#todo)
  - [Тестирование](#тестирование)
    - [Нагрузочное тестирование](#нагрузочное-тестирование)
      - [Load Test 1](#load-test-1)
      - [Load Test 2](#load-test-2)
      - [Load Test 3](#load-test-3)
    - [Профилирование во время нагрузочных тестов и после](#профилирование-во-время-нагрузочных-тестов-и-после)

## Подход к решению задачи

Увидев тестовое в первый раз, я удивился: "Какое-то оно очень простое и маленькое по сравнению с прошлым (Осень 2024)". Но потом увидел условия, а там тесты.

Решил не использовать кодогенерацию, так как API небольшой, все быстренько руками сам написал. 

Для написания API думал взять даже `net/http`, но потом подумал, что лучше `echo` использую. 

Для работы с базой данных использовал `pgx`, это я даже не обдумывал, а сразу решил.

## Архитектура сервера

Я решил, что архитектура должна быть 3-х уровневая: 

1. API
2. Service
3. Database

Запросы поступают в API, биндятся к структурам, отражающим входные данные, валидируются при помощи `go-playground/validator/v10` и далее, если все хорошо, данные запросов передаются в `service layer` в структурах, в названии которых в конце есть `Params`.

Стрктуры с окончанием `Params` несут в себе смысл параметров запросов, то есть там данные тел самих запросов. Это сделано для разделения уровней.

В `service layer` поступают уже валидированные данные. То есть, если отправить запрос на отправку монет и указать там `amount < 0`, то такой запрос не дойдет даже до уровня `service`. Здесь данные передаются в `database layer`. **Можно спросить: а зачем нужен `service layer`, если он как таковой функции не выполняет?** А нужен этот слой, потому что этой слой БЛ (бизнес логики). Если придется добавлять, например, работу с кэшированием через `redis` или запросы к внешним API, то их правильно будет расположить на этом слое. Тогда код `API layer` и `database layer` не будет изменен. Да и эти слои не должны этим заниматься.

В `database layer` выполняются запросы к базе `PostgreSQL`, результат возвращается в `service layer`, а оттуда в `API layer`.

## Обработка ошибок

Я этому моменту уделил довольно много времени. Решил остановиться на довольно простом варианте:

1. Есть ошибки уровня базы данных, сервисного уровня.
2. База возвращает обернутые ошибки `err` с заранее опредленным ошибками моими.
3. Сервис имеет аналогичный набор ошибок заранее определенных. Он маппит ошибки уровня базы в свои и отдают уже свои ошибки.
4. API маппит ошибки сервиса в `http` коды и отдает всегда `status code`.

Это довольно тривиальный подход, но весь маппинг зато вынесем в отдельные 2 функции, а в `API layer` и в `service layer` остается только вызвать функцию маппинга.

`Wrap` на уровне базы есть, чтобы в `service layer` можно было залоггировать ошибку полную, а в API отдать только самое важное.

## Проектирование базы данных

При проектировании я отталкивался от возможных сущностей и от сущностей, описанных в спецификации.

Я выделил, что необходимо создать следующие таблицы:

1. `users`
2. `wallets`
3. `transactions`
4. `items`
5. `inventory`

`users` отвечает за хранение информации о пользователе.
`wallets` представляет из себя кошелек пользователя. Создается в момент создания юзера автоматически.
`transactions` хранит в себе транзакции между пользователями, но не хранит операции о покупках вещей.
`items` просто хранит все указанные в описании задания предметы и их стоимости.
`inventory` представляет из себя инвентарь пользователя, а именно предмет и количество этого предмета у конкретного пользователя по его `ID`.

## TODO

- [x] Спроектировать архитектуру сервиса
- [x] Написать методы для работы с базой
- [x] Написать методы сервисного уровня
- [x] Написать API обработчики
- [ ] Изменить `bcrypt` на что-то другое, чтобы повысить производительность (опционально)
- [x] Написать интеграционные тесты
- [x] Написать unit-тесты
- [ ] Почистить код, переименовать некоторые методы/функции/переменные
- [x] Написать `Dockerfile` и `docker-compose.yml` файлы
- [ ] Сделать `doc` комментарии у пакетов (опционально)
- [x] Перепроектировать маппинг ошибок от базы к API (опционально)
- [ ] Написать полный `README.md`
- [ ] Добавить еще линтеров (опционально)
- [x] Провести нагрузочное тестирование, добавить в `README.md`
- [x] Добавить профилирование
- [x] Добавить теги `validate`
- [x] Убрать базу из сервера
- [x] Прокидывать секрет для JWT где-то извне
- [ ] Глобальный рефакторинг
- [ ] Добавить запуск тестов перед запуском сервера (очень опционально)


## Тестирование


### Нагрузочное тестирование

#### Load Test 1

Для проведения нагрузочного тестирования я решил использовать инструмент `k6`. Он очень прост в использовании (за исключением моего плохого знания `js`). Для такого тестирования был написан файлик `load_test.js`. Все параметры в нем указаны, как и в выводе результатов ниже. 

**Тестовый файл**: `load_test.js`

Тест запускается такой командой:
```sh
k6 run load_test.js
```

Результаты тестирования:

```sh
         /\      Grafana   /‾‾/  
    /\  /  \     |\  __   /  /   
   /  \/    \    | |/ /  /   ‾‾\ 
  /          \   |   (  |  (‾)  |
 / __________ \  |_|\_\  \_____/ 

     execution: local
        script: load_test.js
        output: -

     scenarios: (100.00%) 1 scenario, 500 max VUs, 1m30s max duration (incl. graceful stop):
              * default: 500 looping VUs for 1m0s (gracefulStop: 30s)


     ✓ Info success
     ✓ Buy success
     ✓ SendCoin success

     █ setup

       ✓ Auth success

   ✓ checks.........................: 100.00% 59839 out of 59839
     data_received..................: 11 MB   180 kB/s
     data_sent......................: 16 MB   258 kB/s
     http_req_blocked...............: avg=11.62µs  min=1.37µs   med=4.79µs   max=26.59ms p(90)=8.06µs   p(95)=9.69µs  
     http_req_connecting............: avg=5.62µs   min=0s       med=0s       max=26.54ms p(90)=0s       p(95)=0s      
   ✓ http_req_duration..............: avg=583.04µs min=115.38µs med=561.28µs max=76.59ms p(90)=900.69µs p(95)=1.08ms  
       { expected_response:true }...: avg=723.94µs min=338.41µs med=618.42µs max=76.59ms p(90)=972.35µs p(95)=1.16ms  
     http_req_failed................: 66.66%  39892 out of 59839
     http_req_receiving.............: avg=44.66µs  min=8.1µs    med=38.79µs  max=4.95ms  p(90)=69.04µs  p(95)=80.99µs 
     http_req_sending...............: avg=16.61µs  min=3.6µs    med=14.43µs  max=1.3ms   p(90)=25.18µs  p(95)=30.58µs 
     http_req_tls_handshaking.......: avg=0s       min=0s       med=0s       max=0s      p(90)=0s       p(95)=0s      
     http_req_waiting...............: avg=521.76µs min=80.51µs  med=509.57µs max=76.38ms p(90)=818.91µs p(95)=982.43µs
     http_reqs......................: 59839   974.272818/s
     iteration_duration.............: avg=1.52s    min=1s       med=1.5s     max=2.49s   p(90)=1.5s     p(95)=1.67s   
     iterations.....................: 19946   324.752179/s
     vus............................: 216     min=216            max=500
     vus_max........................: 500     min=500            max=500


running (1m01.4s), 000/500 VUs, 19946 complete and 0 interrupted iterations
default ✓ [======================================] 500 VUs  1m0s
```

Стоит пояснить, почему `http_req_failed` **66%**, то есть всего **34%** тестов были успешны. Дело в том, что `http_req_failed` **считает за проваленный любой тест, который вернул код, отличающийся от** `2xx` или `3xx`. А, так как при создании пользователя у него имеется всего 1000 монет, то, например, отправлять 10000 раз по 1 монете и получать **200** код, **не получится**, потому что API отдает **400** код с ошибкой `"insuffisient funds"`. Поэтому было принято решение добавить в `thresholds` метрику `checks` и добавить в `check` **400** код как валидный, **потому что это ожидаемый ответ от сервера при отсутствии средств**.

А **34%** успешных тестов, потому что 1 тест - `/api/auth`, а остальные это `/api/info`, то есть получение информации, а в этих тестах все корректно отработало.

#### Load Test 2

В этом тесте я решил сделать иначе. Я тестирую только отправку монет между юзерами.

Создается 2 юзера, и они по очереди отправляют друг другу по 1 монете

**Тестовый файл**: `load_test_send_coin.js`

*Тест запускается такой командой:*

```sh
k6 run load_test_send_coin.js
```

*Результаты теста:*

```sh
         /\      Grafana   /‾‾/  
    /\  /  \     |\  __   /  /   
   /  \/    \    | |/ /  /   ‾‾\ 
  /          \   |   (  |  (‾)  |
 / __________ \  |_|\_\  \_____/ 

     execution: local
        script: load_test_send_coin.js
        output: -

     scenarios: (100.00%) 1 scenario, 500 max VUs, 1m30s max duration (incl. graceful stop):
              * default: 500 looping VUs for 1m0s (gracefulStop: 30s)


     ✗ SendCoin success
      ↳  65% — ✓ 19628 / ✗ 10372

     █ setup

       ✓ Auth loadtest2user1 success
       ✓ Auth loadtest2user2 success

   ✗ checks.........................: 65.42% 19630 out of 30002
     data_received..................: 3.2 MB 52 kB/s
     data_sent......................: 9.8 MB 161 kB/s
     http_req_blocked...............: avg=17.84µs min=1.42µs   med=6.46µs  max=19.6ms  p(90)=10.71µs p(95)=13.11µs
     http_req_connecting............: avg=8.8µs   min=0s       med=0s      max=19.49ms p(90)=0s      p(95)=0s     
   ✓ http_req_duration..............: avg=2.2ms   min=766.19µs med=1.7ms   max=99.3ms  p(90)=2.71ms  p(95)=3.84ms 
       { expected_response:true }...: avg=1.85ms  min=1.04ms   med=1.63ms  max=79.88ms p(90)=2.39ms  p(95)=2.86ms 
   ✗ http_req_failed................: 34.57% 10372 out of 30002
     http_req_receiving.............: avg=54µs    min=8.9µs    med=45.84µs max=1.8ms   p(90)=78.41µs p(95)=98.53µs
     http_req_sending...............: avg=28.69µs min=5.8µs    med=24.97µs max=7ms     p(90)=41.38µs p(95)=49.68µs
     http_req_tls_handshaking.......: avg=0s      min=0s       med=0s      max=0s      p(90)=0s      p(95)=0s     
     http_req_waiting...............: avg=2.12ms  min=692.93µs med=1.62ms  max=99.19ms p(90)=2.6ms   p(95)=3.7ms  
     http_reqs......................: 30002  491.80274/s
     iteration_duration.............: avg=1s      min=1s       med=1s      max=1.49s   p(90)=1s      p(95)=1.01s  
     iterations.....................: 30000  491.769955/s
     vus............................: 66     min=66             max=500
     vus_max........................: 500    min=500            max=500


running (1m01.0s), 000/500 VUs, 30000 complete and 0 interrupted iterations
default ✓ [======================================] 500 VUs  1m0s
ERRO[0061] thresholds on metrics 'checks, http_req_failed' have been crossed
```

Можно заметить, что результаты гораздо хуже. За корректный ответ считался только код 200.

Это можно легко объяснить, так как отправка монет выполняется в рамках транзакции, поэтому присутствует блокировка данных. Из-за этого нельзя было получить доступ к ним, пока другая транзакция не завершится. Уровен изоляции: `Serializable`, что гарантирует отсутствие "грязного" чтения, неповторяемого чтения, фантомного чтения и аномалий сериализации. Это особенно важно, когда мы говорим про денежные переводы. 

Это означает, что многие попытки перевода были отклонены сервером в виду того, что была открыта какая-то другая транзакция.

**Самое важное, как я считаю:** изначально у одного юзера было 1000 монет, у второго 1000 монет, а по итогам тестирования у первого стало 1223, второго 777, **а значит никаких аномалий с деньгами не произошло**. Просто многие переводы были отклонены.

#### Load Test 3

Этот тест был направлен только на запрос `/api/info`.

**Тестовый файл**: `load_test_info.js`

Запускать командой:

```sh
k6 run load_test_info.js
```

```sh
         /\      Grafana   /‾‾/  
    /\  /  \     |\  __   /  /   
   /  \/    \    | |/ /  /   ‾‾\ 
  /          \   |   (  |  (‾)  |
 / __________ \  |_|\_\  \_____/ 

     execution: local
        script: load_test_info.js
        output: -

     scenarios: (100.00%) 1 scenario, 500 max VUs, 1m30s max duration (incl. graceful stop):
              * default: 500 looping VUs for 1m0s (gracefulStop: 30s)


     ✓ Info success

     █ setup

       ✓ Auth success

   ✓ checks.........................: 100.00% 30001 out of 30001
     data_received..................: 5.9 MB  98 kB/s
     data_sent......................: 7.0 MB  115 kB/s
     http_req_blocked...............: avg=18.11µs  min=1.22µs   med=4.72µs   max=30.03ms p(90)=8.06µs  p(95)=10.05µs
     http_req_connecting............: avg=11.73µs  min=0s       med=0s       max=29.91ms p(90)=0s      p(95)=0s     
   ✓ http_req_duration..............: avg=852.37µs min=421.01µs med=718.72µs max=72.75ms p(90)=1.09ms  p(95)=1.3ms  
       { expected_response:true }...: avg=852.37µs min=421.01µs med=718.72µs max=72.75ms p(90)=1.09ms  p(95)=1.3ms  
   ✓ http_req_failed................: 0.00%   0 out of 30001
     http_req_receiving.............: avg=47.33µs  min=8.31µs   med=41.97µs  max=2.96ms  p(90)=69.02µs p(95)=81.68µs
     http_req_sending...............: avg=15.14µs  min=4.06µs   med=12.51µs  max=1.4ms   p(90)=22µs    p(95)=27.39µs
     http_req_tls_handshaking.......: avg=0s       min=0s       med=0s       max=0s      p(90)=0s      p(95)=0s     
     http_req_waiting...............: avg=789.89µs min=392.15µs med=660.34µs max=71.8ms  p(90)=1.01ms  p(95)=1.21ms 
     http_reqs......................: 30001   493.537802/s
     iteration_duration.............: avg=1s       min=1s       med=1s       max=1.5s    p(90)=1s      p(95)=1s     
     iterations.....................: 30000   493.521352/s
     vus............................: 500     min=500            max=500
     vus_max........................: 500     min=500            max=500


running (1m00.8s), 000/500 VUs, 30000 complete and 0 interrupted iterations
default ✓ [======================================] 500 VUs  1m0s
```

Результаты показывают, что **все запросы оказались успешными, а среднее время задержки меньше 1мс**.

### Профилирование во время нагрузочных тестов и после

Во время проведения нагрузочных тестов результаты профилирования были следующими:

```sh
Types of profiles available:
Count	Profile
101	allocs
0	block
0	cmdline
514	goroutine
101	heap
0	mutex
0	profile
22	threadcreate
0	trace
```

А после профилирования такие:

```sh
Types of profiles available:
Count	Profile
129	allocs
0	block
0	cmdline
9	goroutine
129	heap
0	mutex
0	profile
21	threadcreate
0	trace
```

Утечек горутин нет.