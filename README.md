# Merch Shop (Avito Trainee Task)

[![Go Report Card](https://goreportcard.com/badge/github.com/0x0FACED/merch-shop)](https://goreportcard.com/report/github.com/0x0FACED/merch-shop)


Это мое решение тестового задания в Avito на позицию Backend Developer.

## Table of Contents

- [Merch Shop (Avito Trainee Task)](#merch-shop-avito-trainee-task)
	- [Table of Contents](#table-of-contents)
	- [Подход к решению задачи](#подход-к-решению-задачи)
	- [TODO](#todo)
	- [Тестирование](#тестирование)
		- [Нагрузочное тестирование](#нагрузочное-тестирование)
			- [Load Test 1](#load-test-1)
			- [Load Test 2](#load-test-2)
		- [Профилирование во время нагрузочных тестов и после](#профилирование-во-время-нагрузочных-тестов-и-после)

## Подход к решению задачи

Увидев тестовое в первый раз, я удивился: "Какое-то оно очень простое и маленькое по сравнению с прошлым (Осень 2024)". Но потом увидел условия, а там тесты.

Решил не использовать кодогенерацию, так как API небольшой, все быстренько руками сам написал. 

Для написания API думал взять даже `net/http`, но потом подумал, что лучше `echo` использую. 

Для работы с базой данных использовал `pgx`, это я даже не обдумывал, а сразу решил.

## TODO

- [x] Спроектировать архитектуру сервиса
- [x] Написать методы для работы с базой
- [x] Написать методы сервисного уровня
- [x] Написать API обработчики
- [ ] Изменить `bcrypt` на что-то другое, чтобы повысить производительность (опционально)
- [x] Написать интеграционные тесты
- [x] Написать unit-тесты
- [ ] Почистить код, переименовать некоторые методы/функции/переменные
- [ ] Написать `Dockerfile` и `docker-compose.yml` файлы
- [ ] Сделать `doc` комментарии у пакетов (опционально)
- [x] Перепроектировать маппинг ошибок от базы к API (опционально)
- [ ] Написать полный `README.md`
- [ ] Добавить еще линтеров (опционально)
- [x] Провести нагрузочное тестирование, добавить в `README.md`
- [x] Добавить профилирование
- [x] Добавить теги `validate`
- [x] Убрать базу из сервера
- [ ] Прокидывать секрет для JWT где-то извне


## Тестирование


### Нагрузочное тестирование

#### Load Test 1

Для проведения нагрузочного тестирования я решил использовать инструмент `k6`. Он очень прост в использовании (за исключением моего плохого знания `js`). Для такого тестирования был написан файлик `load_test.js`. Все параметры в нем указаны, как и в выводе результатов ниже. 

**Тестовый файл**: `load_test.js`

Тест запускается такой командой:
```sh
k6 run load_test.js
```

Результаты тестирования:

```sh
         /\      Grafana   /‾‾/  
    /\  /  \     |\  __   /  /   
   /  \/    \    | |/ /  /   ‾‾\ 
  /          \   |   (  |  (‾)  |
 / __________ \  |_|\_\  \_____/ 

     execution: local
        script: load_test.js
        output: -

     scenarios: (100.00%) 1 scenario, 500 max VUs, 1m30s max duration (incl. graceful stop):
              * default: 500 looping VUs for 1m0s (gracefulStop: 30s)


     ✓ Info success
     ✓ Buy success
     ✓ SendCoin success

     █ setup

       ✓ Auth success

   ✓ checks.........................: 100.00% 59839 out of 59839
     data_received..................: 11 MB   180 kB/s
     data_sent......................: 16 MB   258 kB/s
     http_req_blocked...............: avg=11.62µs  min=1.37µs   med=4.79µs   max=26.59ms p(90)=8.06µs   p(95)=9.69µs  
     http_req_connecting............: avg=5.62µs   min=0s       med=0s       max=26.54ms p(90)=0s       p(95)=0s      
   ✓ http_req_duration..............: avg=583.04µs min=115.38µs med=561.28µs max=76.59ms p(90)=900.69µs p(95)=1.08ms  
       { expected_response:true }...: avg=723.94µs min=338.41µs med=618.42µs max=76.59ms p(90)=972.35µs p(95)=1.16ms  
     http_req_failed................: 66.66%  39892 out of 59839
     http_req_receiving.............: avg=44.66µs  min=8.1µs    med=38.79µs  max=4.95ms  p(90)=69.04µs  p(95)=80.99µs 
     http_req_sending...............: avg=16.61µs  min=3.6µs    med=14.43µs  max=1.3ms   p(90)=25.18µs  p(95)=30.58µs 
     http_req_tls_handshaking.......: avg=0s       min=0s       med=0s       max=0s      p(90)=0s       p(95)=0s      
     http_req_waiting...............: avg=521.76µs min=80.51µs  med=509.57µs max=76.38ms p(90)=818.91µs p(95)=982.43µs
     http_reqs......................: 59839   974.272818/s
     iteration_duration.............: avg=1.52s    min=1s       med=1.5s     max=2.49s   p(90)=1.5s     p(95)=1.67s   
     iterations.....................: 19946   324.752179/s
     vus............................: 216     min=216            max=500
     vus_max........................: 500     min=500            max=500


running (1m01.4s), 000/500 VUs, 19946 complete and 0 interrupted iterations
default ✓ [======================================] 500 VUs  1m0s
```

Стоит пояснить, почему `http_req_failed` **66%**, то есть всего **34%** тестов были успешны. Дело в том, что `http_req_failed` **считает за проваленный любой тест, который вернул код, отличающийся от** `2xx` или `3xx`. А, так как при создании пользователя у него имеется всего 1000 монет, то, например, отправлять 10000 раз по 1 монете и получать **200** код, **не получится**, потому что API отдает **400** код с ошибкой `"insuffisient funds"`. Поэтому было принято решение добавить в `thresholds` метрику `checks` и добавить в `check` **400** код как валидный, **потому что это ожидаемый ответ от сервера при отсутствии средств**.

А **34%** успешных тестов, потому что 1 тест - `/api/auth`, а остальные это `/api/info`, то есть получение информации, а в этих тестах все корректно отработало.

#### Load Test 2

В этом тесте я решил сделать иначе. Я тестирую только отправку монет между юзерами.

Создается 2 юзера, и они по очереди отправляют друг другу по 1 монете

**Тестовый файл**: `load_test_send_coin.js`

*Тест запускается такой командой:*

```sh
k6 run load_test_send_coin.js
```

*Результаты теста:*

```sh
         /\      Grafana   /‾‾/  
    /\  /  \     |\  __   /  /   
   /  \/    \    | |/ /  /   ‾‾\ 
  /          \   |   (  |  (‾)  |
 / __________ \  |_|\_\  \_____/ 

     execution: local
        script: load_test_send_coin.js
        output: -

     scenarios: (100.00%) 1 scenario, 500 max VUs, 1m30s max duration (incl. graceful stop):
              * default: 500 looping VUs for 1m0s (gracefulStop: 30s)


     ✗ SendCoin success
      ↳  65% — ✓ 19628 / ✗ 10372

     █ setup

       ✓ Auth loadtest2user1 success
       ✓ Auth loadtest2user2 success

   ✗ checks.........................: 65.42% 19630 out of 30002
     data_received..................: 3.2 MB 52 kB/s
     data_sent......................: 9.8 MB 161 kB/s
     http_req_blocked...............: avg=17.84µs min=1.42µs   med=6.46µs  max=19.6ms  p(90)=10.71µs p(95)=13.11µs
     http_req_connecting............: avg=8.8µs   min=0s       med=0s      max=19.49ms p(90)=0s      p(95)=0s     
   ✓ http_req_duration..............: avg=2.2ms   min=766.19µs med=1.7ms   max=99.3ms  p(90)=2.71ms  p(95)=3.84ms 
       { expected_response:true }...: avg=1.85ms  min=1.04ms   med=1.63ms  max=79.88ms p(90)=2.39ms  p(95)=2.86ms 
   ✗ http_req_failed................: 34.57% 10372 out of 30002
     http_req_receiving.............: avg=54µs    min=8.9µs    med=45.84µs max=1.8ms   p(90)=78.41µs p(95)=98.53µs
     http_req_sending...............: avg=28.69µs min=5.8µs    med=24.97µs max=7ms     p(90)=41.38µs p(95)=49.68µs
     http_req_tls_handshaking.......: avg=0s      min=0s       med=0s      max=0s      p(90)=0s      p(95)=0s     
     http_req_waiting...............: avg=2.12ms  min=692.93µs med=1.62ms  max=99.19ms p(90)=2.6ms   p(95)=3.7ms  
     http_reqs......................: 30002  491.80274/s
     iteration_duration.............: avg=1s      min=1s       med=1s      max=1.49s   p(90)=1s      p(95)=1.01s  
     iterations.....................: 30000  491.769955/s
     vus............................: 66     min=66             max=500
     vus_max........................: 500    min=500            max=500


running (1m01.0s), 000/500 VUs, 30000 complete and 0 interrupted iterations
default ✓ [======================================] 500 VUs  1m0s
ERRO[0061] thresholds on metrics 'checks, http_req_failed' have been crossed
```

Можно заметить, что результаты гораздо хуже. За корректный ответ считался только код 200.

Это можно легко объяснить, так как отправка монет выполняется в рамках транзакции, поэтому присутствует блокировка данных. Из-за этого нельзя было получить доступ к ним, пока другая транзакция не завершится. Уровен изоляции: `Serializable`, что гарантирует отсутствие "грязного" чтения, неповторяемого чтения, фантомного чтения и аномалий сериализации. Это особенно важно, когда мы говорим про денежные переводы. 

Это означает, что многие попытки перевода были отклонены сервером в виду того, что была открыта какая-то другая транзакция.

**Самое важное, как я считаю:** изначально у одного юзера было 1000 монет, у второго 1000 монет, а по итогам тестирования у первого стало 1223, второго 777, **а значит никаких аномалий с деньгами не произошло**. Просто многие переводы были отклонены.

### Профилирование во время нагрузочных тестов и после

Во время проведения нагрузочных тестов результаты профилирования были следующими:

```sh
Types of profiles available:
Count	Profile
101	allocs
0	block
0	cmdline
514	goroutine
101	heap
0	mutex
0	profile
22	threadcreate
0	trace
```

А после профилирования такие:

```sh
Types of profiles available:
Count	Profile
129	allocs
0	block
0	cmdline
9	goroutine
129	heap
0	mutex
0	profile
21	threadcreate
0	trace
```

Утечек горутин нет.